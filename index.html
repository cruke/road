<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>POV Lane – Cones Mid-Lane + Size/Frequency</title>
<style>
  html,body{margin:0;height:100%;background:#111;color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
  .bar{
    display:flex;gap:12px;align-items:center;flex-wrap:wrap;
    padding:10px 12px;border-bottom:1px solid #2a2a2a;background:#141414;font-size:14px;
  }
  label{display:flex;align-items:center;gap:8px;white-space:nowrap;}
  input[type="range"]{width:170px;}
  .btn{padding:6px 10px;border:1px solid #333;background:#1b1b1b;color:#eee;border-radius:8px;cursor:pointer;}
  canvas{display:block;width:100%;height:calc(100vh - 56px);}
  .pill{padding:4px 8px;border:1px solid #333;border-radius:999px;background:#1b1b1b;font-size:12px;opacity:.9}
  .pill.ok{border-color:#2b5;background:#132;}
  .pill.bad{border-color:#b44;background:#211;}
</style>
</head>
<body>

<div class="bar">
  <button class="btn" id="pauseBtn">Pause</button>
  <span class="pill" id="wakePill" title="Screen Wake Lock status">Wake: off</span>

  <label>Speed <span id="speedVal">2</span>
    <input id="speed" type="range" min="1" max="25" value="2">
  </label>

  <label>Lane width <span id="laneVal">0.56</span>
    <input id="laneW" type="range" min="0.35" max="0.9" step="0.01" value="0.56">
  </label>

  <label>Dash length <span id="dashLenVal">80</span>
    <input id="dashLen" type="range" min="10" max="80" value="80">
  </label>

  <label>Dash gap <span id="dashGapVal">153</span>
    <input id="dashGap" type="range" min="10" max="800" value="153">
  </label>

  <label>Gap strength <span id="gapStrVal">7.5</span>
    <input id="gapStr" type="range" min="1" max="12" step="0.5" value="7.5">
  </label>

  <label>Line thickness <span id="thickVal">1.70</span>
    <input id="thick" type="range" min="0.7" max="2.5" step="0.05" value="1.70">
  </label>

  <label>Curve extreme <span id="curveMaxVal">1.85</span>
    <input id="curveMax" type="range" min="0.2" max="2.0" step="0.05" value="1.85">
  </label>

  <label>Curve change rate <span id="curveRateVal">1.35</span>
    <input id="curveRate" type="range" min="0.25" max="2.5" step="0.05" value="1.35">
  </label>

  <label>Cone size <span id="coneSizeVal">3.00</span>
    <input id="coneSize" type="range" min="0.5" max="6.0" step="0.05" value="3.00">
  </label>

  <label>Cone frequency <span id="coneFreqVal">1.00</span>
    <input id="coneFreq" type="range" min="0.2" max="3.0" step="0.05" value="1.00">
  </label>
</div>

<canvas id="cv"></canvas>

<script>
(() => {
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d", { alpha:false });

  const el = {
    speed: document.getElementById("speed"),
    laneW: document.getElementById("laneW"),
    dashLen: document.getElementById("dashLen"),
    dashGap: document.getElementById("dashGap"),
    gapStr: document.getElementById("gapStr"),
    thick: document.getElementById("thick"),
    curveMax: document.getElementById("curveMax"),
    curveRate: document.getElementById("curveRate"),
    coneSize: document.getElementById("coneSize"),
    coneFreq: document.getElementById("coneFreq"),
    pauseBtn: document.getElementById("pauseBtn"),
    wakePill: document.getElementById("wakePill"),
  };
  const val = {
    speed: document.getElementById("speedVal"),
    laneW: document.getElementById("laneVal"),
    dashLen: document.getElementById("dashLenVal"),
    dashGap: document.getElementById("dashGapVal"),
    gapStr: document.getElementById("gapStrVal"),
    thick: document.getElementById("thickVal"),
    curveMax: document.getElementById("curveMaxVal"),
    curveRate: document.getElementById("curveRateVal"),
    coneSize: document.getElementById("coneSizeVal"),
    coneFreq: document.getElementById("coneFreqVal"),
  };

  const WHITE = "rgb(255,255,255)";

  // ===== Auto-save (localStorage) =====
  const STORE_KEY = "pov_lane_settings_v4";

  // DEFAULTS updated to match your screenshot
  const DEFAULTS = {
    speed: "2",
    laneW: "0.56",
    dashLen: "80",
    dashGap: "153",
    gapStr: "7.5",
    thick: "1.70",
    curveMax: "1.85",
    curveRate: "1.35",
    coneSize: "3.00",
    coneFreq: "1.00",
    paused: false
  };

  let paused = DEFAULTS.paused;

  function loadSettings(){
    try{
      const raw = localStorage.getItem(STORE_KEY);
      if(!raw) return;
      const s = JSON.parse(raw);
      for (const k of Object.keys(DEFAULTS)){
        if (!(k in s)) continue;
        if (k === "paused") continue;
        if (el[k]) el[k].value = String(s[k]);
      }
      if (typeof s.paused === "boolean") paused = s.paused;
    }catch(e){}
  }

  let saveTimer = null;
  function saveSettingsSoon(){
    clearTimeout(saveTimer);
    saveTimer = setTimeout(() => {
      const s = {
        speed: el.speed.value,
        laneW: el.laneW.value,
        dashLen: el.dashLen.value,
        dashGap: el.dashGap.value,
        gapStr: el.gapStr.value,
        thick: el.thick.value,
        curveMax: el.curveMax.value,
        curveRate: el.curveRate.value,
        coneSize: el.coneSize.value,
        coneFreq: el.coneFreq.value,
        paused
      };
      try{ localStorage.setItem(STORE_KEY, JSON.stringify(s)); }catch(e){}
    }, 120);
  }

  function bindAutoSave(){
    const ids = ["speed","laneW","dashLen","dashGap","gapStr","thick","curveMax","curveRate","coneSize","coneFreq"];
    ids.forEach(id => {
      const node = el[id];
      node.addEventListener("input", saveSettingsSoon);
      node.addEventListener("change", saveSettingsSoon);
    });
  }

  // ===== Wake Lock =====
  let wakeLock = null;
  function setWakeUI(state, cls) {
    el.wakePill.textContent = `Wake: ${state}`;
    el.wakePill.classList.remove("ok","bad");
    if (cls) el.wakePill.classList.add(cls);
  }
  async function requestWakeLock() {
    try {
      if (!("wakeLock" in navigator)) { setWakeUI("unsupported","bad"); return; }
      if (wakeLock) return;
      wakeLock = await navigator.wakeLock.request("screen");
      setWakeUI("on","ok");
      wakeLock.addEventListener("release", () => {
        wakeLock = null;
        if (!paused && document.visibilityState === "visible") setWakeUI("releasing…", null);
        else setWakeUI("off", null);
      });
    } catch (e) {
      setWakeUI("blocked","bad");
      wakeLock = null;
    }
  }
  async function releaseWakeLock() {
    try { if (wakeLock) { await wakeLock.release(); wakeLock = null; } }
    finally { setWakeUI("off", null); }
  }
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "visible") {
      if (!paused) requestWakeLock();
    } else {
      releaseWakeLock();
    }
  });

  // ===== Canvas sizing =====
  function resize(){
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    cv.width = Math.floor(cv.clientWidth * dpr);
    cv.height = Math.floor(cv.clientHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resize);

  // ===== Motion =====
  let t = 0, last = performance.now();
  let travel = 0;

  // ===== Extreme curve =====
  let currentCurve = 0;
  let targetCurve = 0;
  let nextChange = 0;

  function randSigned(){ return (Math.random()<0.5?-1:1); }

  function newCurve(){
    const max = +el.curveMax.value;
    const r = Math.random();
    const mag = (0.15 + (r*r)*0.85) * max;
    const flip = (Math.random() < 0.40);
    const straight = (Math.random() < 0.06);

    if (straight) targetCurve = (Math.random()*0.10 - 0.05) * max;
    else if (flip) targetCurve = -Math.sign(currentCurve || 1) * mag;
    else targetCurve = randSigned() * mag;

    const rate = +el.curveRate.value;
    const minMs = 380 / rate;
    const maxMs = 1150 / rate;
    nextChange = performance.now() + (minMs + Math.random()*(maxMs-minMs));
  }

  // ===== Perspective =====
  function yFromZ(z,H){
    const p=2.15;
    return (Math.pow(z,p))*(H*0.90) + (H*0.08);
  }
  function centerX(z,W){
    const ahead = (1 - z);
    return currentCurve * (ahead*ahead) * W * 0.48;
  }

  // ===== Cones =====
  const cones = [];
  let nextConeAtTravel = 700;

  function coneSpacing(speed){
    const freq = +el.coneFreq.value; // higher => more cones
    const baseMin = 700;
    const baseMax = 1900;

    const s = Math.max(1, Math.min(25, speed));
    const speedFactor = 1.15 - (s / 25) * 0.45;

    const freqFactor = 1 / Math.max(0.05, freq);

    const min = baseMin * speedFactor * freqFactor;
    const max = baseMax * speedFactor * freqFactor;

    return min + Math.random() * (max - min);
  }

  function spawnCone(speed){
    const side = Math.random() < 0.5 ? -1 : 1;

    // exactly mid between dashed centerline and side line
    const midFactor = 0.5;

    const zStart = Math.random() * 0.04;

    cones.push({
      spawnTravel: travel,
      baseStart: zStart,
      side,
      factor: midFactor
    });

    nextConeAtTravel = travel + coneSpacing(speed);
  }

  function drawCone(x, y, scale){
    const h = 18 * scale;
    const w = 14 * scale;
    const topW = 5.5 * scale;
    const baseH = 4.5 * scale;

    // base
    ctx.fillStyle = "#222";
    ctx.fillRect(x - (w*0.65), y - baseH, w*1.3, baseH);

    // cone body (no stripe)
    ctx.fillStyle = "#ff7a00";
    ctx.beginPath();
    ctx.moveTo(x - w/2, y - baseH);
    ctx.lineTo(x + w/2, y - baseH);
    ctx.lineTo(x + topW/2, y - baseH - h);
    ctx.lineTo(x - topW/2, y - baseH - h);
    ctx.closePath();
    ctx.fill();
  }

  async function setPaused(nextPaused){
    paused = nextPaused;
    el.pauseBtn.textContent = paused ? "Resume" : "Pause";
    saveSettingsSoon();
    if (!paused) await requestWakeLock();
    else await releaseWakeLock();
  }

  function draw(){
    const now = performance.now();
    const dt = now - last;
    last = now;

    const W = cv.clientWidth, H = cv.clientHeight;

    const speed = +el.speed.value;
    const laneWv = +el.laneW.value;
    const dashL = +el.dashLen.value;
    const dashG = +el.dashGap.value;
    const gapStr = +el.gapStr.value;
    const thick = +el.thick.value;
    const curveMax = +el.curveMax.value;
    const curveRate = +el.curveRate.value;
    const coneSize = +el.coneSize.value;
    const coneFreq = +el.coneFreq.value;

    val.speed.textContent = speed;
    val.laneW.textContent = laneWv.toFixed(2);
    val.dashLen.textContent = dashL;
    val.dashGap.textContent = dashG;
    val.gapStr.textContent = (+gapStr).toFixed(1);
    val.thick.textContent = thick.toFixed(2);
    val.curveMax.textContent = curveMax.toFixed(2);
    val.curveRate.textContent = curveRate.toFixed(2);
    val.coneSize.textContent = coneSize.toFixed(2);
    val.coneFreq.textContent = coneFreq.toFixed(2);

    if (!paused) {
      t += dt * speed;
      travel += (dt * speed) * 0.0025 * 150;
      if (travel >= nextConeAtTravel) spawnCone(speed);
    }

    if (!paused && now > nextChange) newCurve();

    const rate = +el.curveRate.value;
    const ease = 1 - Math.pow(0.0009, (dt/1000) * rate);
    currentCurve += (targetCurve - currentCurve) * Math.min(1, ease);
    currentCurve = Math.max(-curveMax, Math.min(curveMax, currentCurve));

    // Background
    ctx.fillStyle = "#0b0f1a";
    ctx.fillRect(0,0,W,H);

    // Road
    const topW = W * 0.11, botW = W * 1.40;
    const hy = H * 0.08, by = H * 0.98;

    ctx.fillStyle = "#1a1a1a";
    ctx.beginPath();
    ctx.moveTo(W/2 - topW/2, hy);
    ctx.lineTo(W/2 + topW/2, hy);
    ctx.lineTo(W/2 + botW/2, by);
    ctx.lineTo(W/2 - botW/2, by);
    ctx.closePath();
    ctx.fill();

    // Square ends
    ctx.lineCap = "butt";
    ctx.lineJoin = "miter";

    // Geometry
    const samples = 260;
    const roadW = z => topW + (botW - topW) * z;
    const halfLane = z => roadW(z) * laneWv * 0.5;

    // Side lines
    function drawEdge(side){
      ctx.strokeStyle = WHITE;
      ctx.lineWidth = thick * 10.0;
      ctx.beginPath();
      for (let i=0;i<=samples;i++){
        const z=i/samples;
        const y=yFromZ(z,H);
        const x=(W/2 + centerX(z,W)) + side*halfLane(z);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }
    drawEdge(-1);
    drawEdge( 1);

    // Dashed middle — wide gaps
    const laneDepth = 2200;
    const gapScale = +el.gapStr.value;
    const lenScale = 2.0;

    const effDashL = dashL * lenScale;
    const effDashG = dashG * gapScale;

    const period = effDashL + effDashG;
    const dashCount = Math.ceil(laneDepth / period) + 3;

    for (let k=0;k<dashCount;k++){
      const base = (k * period + (travel % laneDepth)) % laneDepth;
      const zs = base / laneDepth;
      const ze = (base + effDashL) / laneDepth;
      if (ze > 1) continue;

      const y1 = yFromZ(zs,H), y2 = yFromZ(ze,H);
      const x1 = W/2 + centerX(zs,W);
      const x2 = W/2 + centerX(ze,W);

      ctx.strokeStyle = WHITE;
      ctx.lineWidth = thick * (4.0 + ((zs+ze)/2)*10.5);

      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
    }

    // Cones — centered between dashed and side line
    for (let i = cones.length - 1; i >= 0; i--) {
      const c = cones[i];
      const delta = (travel - c.spawnTravel);
      const z = c.baseStart + (delta / laneDepth);

      if (z > 1.02) { cones.splice(i, 1); continue; }

      const y = yFromZ(z, H);
      const cx = W/2 + centerX(z, W);
      const x = cx + c.side * (halfLane(z) * c.factor);

      const persp = (0.55 + z * 2.2);
      const scale = persp * coneSize;

      drawCone(x, y, scale);
    }

    requestAnimationFrame(draw);
  }

  // ---- Init ----
  // Apply defaults first (now matching your screenshot), then load saved settings (if any)
  Object.entries(DEFAULTS).forEach(([k,v]) => {
    if (k === "paused") return;
    if (el[k]) el[k].value = String(v);
  });

  loadSettings();      // overrides defaults if user has saved settings already
  bindAutoSave();

  el.pauseBtn.onclick = () => setPaused(!paused);

  resize();
  newCurve();
  setWakeUI("off", null);
  el.pauseBtn.textContent = paused ? "Resume" : "Pause";

  nextConeAtTravel = coneSpacing(+el.speed.value);

  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
